var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define("voxel/General/BinomialCoefficient", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A function for determining binomial coefficients. Memoized for speed
     *
     * @constructor
     */
    var BinomialCoefficient = /** @class */ (function () {
        function BinomialCoefficient() {
            this.cache = {};
        }
        /**
         * Gets the binomial coefficient using the recursive formula
         *
         * @see http://en.wikipedia.org/wiki/Binomial_coefficient
         *
         * @param  {number} n The number of coefficients
         * @param  {number} k The index of the coefficient
         * @return {number}   The binomial coefficient
         */
        BinomialCoefficient.prototype.get = function (n, k) {
            if (!this.cache.hasOwnProperty(n)) {
                this.cache[n] = {};
            }
            if (!this.cache[n].hasOwnProperty(k)) {
                if (k === 0 || n == k) {
                    this.cache[n][k] = 1;
                }
                else {
                    this.cache[n][k] = this.get(n - 1, k - 1) + this.get(n - 1, k);
                }
            }
            return this.cache[n][k];
        };
        return BinomialCoefficient;
    }());
    exports.default = BinomialCoefficient;
});
define("voxel/General/BezierFunction", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BezierFunction = /** @class */ (function () {
        /**
         * Constructs a new Bezier calculator.
         *
         * @constructor
         * @param {number[]} values       An array of numbers for the bezier function
         * @param {BinomialCoefficient} coefficients A binomial coefficient generator
         */
        function BezierFunction(values, coefficients) {
            this.values = values;
            this.coefficients = coefficients;
        }
        /**
         * Gets the value of the bezier function at a provided time.
         *
         * @param  {number} time A value between 0 and 1
         * @return {number}      The value at the provided time
         */
        BezierFunction.prototype.getAt = function (time) {
            var sum = 0;
            var n = this.values.length - 1;
            for (var i = 0; i <= n; i++) {
                var coefficient = this.coefficients.get(n, i);
                sum += coefficient * Math.pow(1 - time, (n - i)) * Math.pow(time, i) * this.values[i];
            }
            return sum;
        };
        return BezierFunction;
    }());
    exports.default = BezierFunction;
});
define("voxel/Shape/ShapeInterface", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("voxel/Renderer/CanvasRenderer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SIN_THIRTY = Math.sin(Math.PI / 6);
    var COS_THIRTY = Math.cos(Math.PI / 6);
    /**
     * Converts a hex string into an rgba transparent string
     *
     * @param {string} rgbHex the hex color to transparentize
     * @param {number} a The alpha value
     * @return {string} The transparent string
     */
    function transparentize(rgbHex, a) {
        var m = rgbHex.substring(1).match("([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})");
        if (m === null) {
            throw new Error("Invalid hex value " + rgbHex);
        }
        var r = parseInt(m[1], 16);
        var g = parseInt(m[2], 16);
        var b = parseInt(m[3], 16);
        return "rgba(" + r + "," + g + "," + b + "," + a + ")";
    }
    var CanvasRenderer = /** @class */ (function () {
        /**
         * Creates an instance of a CanvasRenderer.
         *
         * @constructor
         * @this {CanvasRenderer}
         * @param {DOMElement} canvas The canvas element to render to
         * @param {number} hypotenuseLength The length of the hypotenuse for drawing diamonds
         * @param {string} leftColor The hex color of the left diamond
         * @param {string} topColor The hex color of the top diamond
         * @param {string} rightColor The hex color of the right diamond
         */
        function CanvasRenderer(canvas, hypotenuseLength, leftColor, topColor, rightColor) {
            this.canvas = canvas;
            this.hypotenuseLength = hypotenuseLength;
            this.offsets = [];
            this.canvas = canvas;
            this.colors = {
                left: leftColor,
                top: topColor,
                right: rightColor
            };
            this.transparentColors = {
                left: transparentize(leftColor, 0.2),
                top: transparentize(topColor, 0.2),
                right: transparentize(rightColor, 0.2)
            };
            this.updateRenderingData(hypotenuseLength);
        }
        /**
         * Sets the desired hypotenuse length for each rendered diamond.
         */
        CanvasRenderer.prototype.updateRenderingData = function (hypotenuseLength) {
            this.hypotenuseLength = hypotenuseLength;
            this.shortLength = hypotenuseLength * SIN_THIRTY;
            this.longLength = hypotenuseLength * COS_THIRTY;
            this.offsets = [
                { x: 0, y: 0 },
                { x: this.longLength, y: this.shortLength },
                { x: 2 * this.longLength, y: 0 },
                { x: 2 * this.longLength, y: -2 * this.shortLength },
                { x: this.longLength, y: -1 * this.shortLength },
                { x: 0, y: -2 * this.shortLength },
                { x: this.longLength, y: -3 * this.shortLength }
            ];
            this.hexCanvas = document.createElement("canvas");
            this.hexCanvas.setAttribute("width", String(Math.ceil(2 * this.longLength)));
            this.hexCanvas.setAttribute("height", String(Math.ceil(2 * this.longLength) + 3));
            this.hexCanvasTrans = document.createElement("canvas");
            this.hexCanvasTrans.setAttribute("width", String(Math.ceil(2 * this.longLength)));
            this.hexCanvasTrans.setAttribute("height", String(Math.ceil(2 * this.longLength) + 3));
            var ctx = this.hexCanvas.getContext("2d");
            this.drawCube(ctx, 0, this.shortLength + this.longLength + 2, false);
            ctx = this.hexCanvasTrans.getContext("2d");
            this.drawCube(ctx, 0, this.shortLength + this.longLength + 2, true);
        };
        /**
         * Given voxel indices, projects them into 2 dimensional space
         *
         * @this {CanvasRenderer}
         * @param {number} x the x index
         * @param {number} y the y index
         * @param {number} z the z index
         * @param {origin} the point at which <0,0> should be rendered.
         */
        CanvasRenderer.prototype.project = function (x, y, z, origin) {
            if (this.longLength === undefined || this.shortLength === undefined) {
                throw new Error("Invalid state");
            }
            x = parseInt(String(x), 10);
            y = parseInt(String(y), 10);
            z = parseInt(String(z), 10);
            return {
                x: origin.x + (this.longLength * (x + y)),
                y: origin.y + (this.shortLength * (y - x)) + (this.hypotenuseLength * -1 * z)
            };
        };
        /**
         * Renders a cube into the provided context
         * @param {CanvasRenderingContext2D} context The context in which to render
         * @param {number} x The x position of the cube
         * @param {number} y The y position of the cube
         * @param {Boolean} transparent Whether or not to draw the cube transparently
         */
        CanvasRenderer.prototype.drawCube = function (context, x, y, transparent) {
            var colors = transparent ? this.transparentColors : this.colors;
            this.drawDiamond(context, x, y, this.offsets[0], this.offsets[1], this.offsets[4], this.offsets[5], colors.left);
            this.drawDiamond(context, x, y, this.offsets[1], this.offsets[2], this.offsets[3], this.offsets[4], colors.right);
            this.drawDiamond(context, x, y, this.offsets[3], this.offsets[4], this.offsets[5], this.offsets[6], colors.top);
        };
        /**
         * Draws the prerendered cube onto the canvas
         *
         * @this {CanvasRenderer}
         * @param {CanvasRenderingContext2D} context The context in which to render
         * @param {number} x The x position of the cube
         * @param {number} y The y position of the cube
         * @param {Boolean} transparent Whether or not to draw the cube transparently
         */
        CanvasRenderer.prototype.drawCubePrerendered = function (context, x, y, transparent) {
            if (this.hexCanvasTrans === undefined || this.hexCanvas === undefined) {
                throw new Error("Invalid canvas state");
            }
            var canvas = transparent ? this.hexCanvasTrans : this.hexCanvas;
            context.drawImage(canvas, Math.round(x), Math.round(y) - 18);
        };
        /**
         * Draws a diamond into the provided context
         *
         * @param  {CanvasRenderingContext2D} context The context in which to render
         * @param  {number} x       The x position of the diamond
         * @param  {number} y       The y position of the diamond
         * @param  {number} offset1 The first point offset from the position
         * @param  {number} offset2 The second point offset from the position
         * @param  {number} offset3 The third point offset from the position
         * @param  {number} offset4 The fourth point offset from the position
         * @param  {string} color   The color to render
         */
        CanvasRenderer.prototype.drawDiamond = function (context, x, y, offset1, offset2, offset3, offset4, color) {
            context.fillStyle = color;
            context.beginPath();
            context.moveTo(x + offset1.x, y + offset1.y);
            context.lineTo(x + offset2.x, y + offset2.y);
            context.lineTo(x + offset3.x, y + offset3.y);
            context.lineTo(x + offset4.x, y + offset4.y);
            context.closePath();
            context.fill();
        };
        /**
         * Given the size of a result matrix, gets size information
         *
         * @param  {number} width The width of the result matrix
         * @param  {number} depth The depth of the result matrix
         * @param  {number} height The height of the result matrix
         * @return {mixed}        The width and height of the canvas, as well as the center.
         */
        CanvasRenderer.prototype.getCanvasSize = function (width, depth, height) {
            if (this.longLength === undefined || this.shortLength === undefined) {
                throw new Error("Uninitialized triangle lengths");
            }
            var canvasWidth = (width + depth) * this.longLength;
            var canvasHeight = (height * this.hypotenuseLength) + ((width + depth) * this.shortLength);
            return {
                width: canvasWidth,
                height: canvasHeight,
                origin: {
                    x: 0,
                    y: canvasHeight - (depth * this.shortLength)
                }
            };
        };
        /**
         * Clears the canvas
         *
         * @this {CanvasRenderer}
         * @todo Implement
         */
        CanvasRenderer.prototype.clearCanvas = function () { };
        /**
         * Renders the shape results onto the canvas element.
         *
         * @param shape A 3d matrix of booleans
         * @param highlightLevel the level at which the levels above disappear
         */
        CanvasRenderer.prototype.render = function (shape, highlightLevel) {
            if (highlightLevel === void 0) { highlightLevel = -1; }
            var totalX = shape[0][0].length;
            var totalY = shape[0].length;
            var totalZ = shape.length;
            var size = this.getCanvasSize(totalX, totalY, totalZ);
            var isCulled = {};
            var maxPlanes = totalZ + totalX + totalY;
            var planePos = [];
            this.canvas.setAttribute("style", "max-width:100%");
            this.canvas.setAttribute("width", size.width + "px");
            this.canvas.setAttribute("height", size.height + "px");
            var context = this.canvas.getContext("2d");
            for (var i = 0; i < maxPlanes; i++) {
                planePos.push([]);
            }
            var startZ = highlightLevel >= 0 ? highlightLevel : totalZ - 1;
            var xSub = totalX - 1;
            for (var z = startZ; z >= 0; z--) {
                for (var y = 0; y < totalY; y++) {
                    for (var x = xSub; x >= 0; x--) {
                        try {
                            if (!shape[z][y][x]) {
                                continue;
                            }
                            var x2 = xSub - x;
                            var min = Math.min(x2, y, z);
                            var key = [x2 - min, y - min, z - min].join(":");
                            var plane = (x2 + y + z);
                            if (!((highlightLevel >= 0 && z <= highlightLevel) || (highlightLevel <= 0))) {
                                continue;
                            }
                            if (isCulled.hasOwnProperty(key)) {
                                continue;
                            }
                            isCulled[key] = plane;
                            planePos[plane].push({ x: x, y: y, z: z });
                        }
                        catch (ex) {
                            console.error(ex.message);
                        }
                    }
                }
            }
            for (var i = 0; i < maxPlanes; i++) {
                for (var j in planePos[i]) {
                    if (!planePos[i].hasOwnProperty(j)) {
                        continue;
                    }
                    var p = planePos[i][j];
                    var pos = this.project(p.x, p.y, p.z, size.origin);
                    this.drawCubePrerendered(context, pos.x, pos.y, false);
                }
            }
            if (highlightLevel >= 0 && highlightLevel < totalZ) {
                var z = highlightLevel + 1;
                for (var y = 0; y < totalY; y++) {
                    for (var x = totalX - 1; x >= 0; x--) {
                        try {
                            if (shape[z][y][x]) {
                                var pos = this.project(x, y, z, size.origin);
                                this.drawCubePrerendered(context, pos.x, pos.y, true);
                            }
                        }
                        catch (ex) {
                            console.error(ex.message);
                        }
                    }
                }
            }
        };
        /**
         * Gets a hypotenuse size given a canvas width and a 3d matrix size
         *
         * @param {number} width The width of the 3d matrix
         * @param {number} depth The depth of the 3d matrix
         * @param {number} height The depth of the 3d matrix
         * @param {number} canvasWidth The width of the canvas in pixels
         */
        CanvasRenderer.getHypotenuseSizeFromWidth = function (width, depth, height, canvasWidth) {
            return (canvasWidth / (width + depth)) / COS_THIRTY;
        };
        /**
         * Gets a hypotenuse size given a canvas height and a 3d matrix size
         *
         * @param {number} width The width of the 3d matrix
         * @param {number} depth The depth of the 3d matrix
         * @param {number} height The depth of the 3d matrix
         * @param {number} canvasHeight The height of the canvas in pixels
         */
        CanvasRenderer.getHypotenuseSizeFromHeight = function (width, depth, height, canvasHeight) {
            return (canvasHeight / (height + ((width + depth) * SIN_THIRTY)));
        };
        return CanvasRenderer;
    }());
    exports.default = CanvasRenderer;
});
define("voxel/Renderer/ConsoleRenderer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ConsoleRenderer = /** @class */ (function () {
        function ConsoleRenderer() {
        }
        ConsoleRenderer.prototype.render = function (matrix) {
            for (var z = 0; z < matrix.length; z++) {
                var str = "";
                for (var y = 0; y < matrix[z].length; y++) {
                    for (var x = 0; x < matrix[z][y].length; x++) {
                        str += matrix[z][y][x] ? "X" : "-";
                    }
                    str += "\n";
                }
                console.log(str + "\n"); // tslint:disable-line
            }
        };
        return ConsoleRenderer;
    }());
    exports.default = ConsoleRenderer;
});
define("voxel/Renderer/SvgLayerRenderer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function roundDec(floatVal, numDec) {
        var mult = Math.pow(10, numDec);
        return Math.round(floatVal * mult) / mult;
    }
    function stringToDoc(text) {
        if (!text || (typeof text) != "string") {
            return null;
        }
        var xmlDoc;
        try {
            if (window.DOMParser) {
                var parser = new window.DOMParser();
                xmlDoc = parser.parseFromString(text, "text/xml");
            }
            else { // IE lt 10
                xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async = false;
                xmlDoc.loadXML(text);
            }
        }
        catch (ignore) { }
        if (xmlDoc && xmlDoc.documentElement && !xmlDoc.getElementsByTagName("parsererror").length) {
            return xmlDoc;
        }
        throw new Error("Invalid XML: " + text);
    }
    var SvgLayerRenderer = /** @class */ (function () {
        function SvgLayerRenderer(bumpHeight) {
            this.bumpHeight = bumpHeight;
        }
        SvgLayerRenderer.prototype.generateLayerSvg = function (shape, layerIndex) {
            if (!shape.hasOwnProperty(layerIndex)) {
                throw new Error("Invalid layer: `" + layerIndex + "`");
            }
            var layer = shape[layerIndex];
            var ySize = roundDec((1 / layer.length) * 100, 2);
            var xSize = roundDec((1 / layer[0].length) * 100, 2);
            var bump = roundDec(ySize * this.bumpHeight, 2);
            var doc = "<svg  xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 " + (100 + bump) + "\">\n";
            for (var y = 0; y < layer.length; y++) {
                for (var x = 0; x < layer[y].length; x++) {
                    var rectClass = null;
                    var thisBump = 0;
                    if (layer[y][x]) {
                        rectClass = "shape";
                        // draw something here
                    }
                    else if (layerIndex > 0 && shape[layerIndex - 1][y][x]) {
                        thisBump = bump;
                        rectClass = "shapeBelow";
                    }
                    else if ((x + y) & 1) {
                        thisBump = bump;
                        rectClass = "fill";
                        // draw other layer
                    }
                    if (rectClass !== null) {
                        doc += '<rect class="' + rectClass + '" ' +
                            'y="' + roundDec((y * ySize) + thisBump, 2) + '" ' +
                            'height="' + ySize + '" ' +
                            'width="' + xSize + '" ' +
                            'x="' + roundDec((x * xSize), 2) + '" />\n';
                    }
                    if (layer[y][x] && (y == layer.length - 1 || !layer[y + 1][x])) {
                        doc += '<rect class="bump" ' +
                            'y="' + roundDec(((y + 1) * ySize), 2) + '" ' +
                            'height="' + bump + '" ' +
                            'width="' + xSize + '" ' +
                            'x="' + roundDec((x * xSize), 2) + '" />\n';
                    }
                }
            }
            doc += "</svg>";
            return stringToDoc(doc);
        };
        return SvgLayerRenderer;
    }());
    exports.default = SvgLayerRenderer;
});
define("voxel/Shape/BaseShape", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseShape = /** @class */ (function () {
        /**
         * Constructor for the BaseShape
         *
         * @constructor
         * @param {number} width     The width of the shape
         * @param {number} depth     The depth of the shape
         * @param {number} height    The height of the shape
         * @param {number|undefined} thickness The thickness of the shape, undefined if solid
         */
        function BaseShape(width, depth, height, thickness) {
            this.width = width;
            this.depth = depth;
            this.height = height;
            this.thickness = thickness;
        }
        BaseShape.prototype.checkDistance = function (distance, radius) {
            if (this.thickness) {
                return (radius - this.thickness <= distance && distance <= radius);
            }
            return distance < radius;
        };
        /**
         * Given a radius, generates a 2d matrix of booleans
         */
        BaseShape.prototype.generateRotation = function (radius) {
            var plane = [];
            var xRadius = (this.width - 1) / 2;
            var yRadius = (this.depth - 1) / 2;
            var minRadius = Math.min(xRadius, yRadius);
            var xRatio = xRadius / minRadius;
            var yRatio = yRadius / minRadius;
            for (var y = -yRadius; y <= yRadius; y++) {
                var row = [];
                for (var x = -xRadius; x <= xRadius; x++) {
                    var distance = Math.sqrt(Math.pow(x / xRatio, 2) +
                        Math.pow(y / yRatio, 2));
                    row.push(this.checkDistance(distance, radius));
                }
                plane.push(row);
            }
            return plane;
        };
        return BaseShape;
    }());
    exports.default = BaseShape;
});
define("voxel/Shape/Bezier", ["require", "exports", "voxel/Shape/BaseShape", "voxel/General/BezierFunction", "voxel/General/BinomialCoefficient"], function (require, exports, BaseShape_1, BezierFunction_1, BinomialCoefficient_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Bezier = /** @class */ (function (_super) {
        __extends(Bezier, _super);
        /**
         * Constructs a shape that can generate a shape from bezier control points
         *
         * @constructor
         * @param {number} width     The width of the shape
         * @param {number} depth     The depth of the shape
         * @param {number} height    The height of the shape
         * @param {number|undefined} thickness The thickness of the shape, or undefined if solid
         * @param {number[]} pointsX   An array of control point x values
         * @param {number[]} pointsY   An array of control point y values
         * @param {string} axis      The string around which to rotate.
         *
         * @todo  respect axis changes
         */
        function Bezier(width, depth, height, thickness, pointsX, pointsY, axis) {
            var _this = _super.call(this, width, depth, height, thickness) || this;
            _this.pointsY = pointsY;
            _this.axis = axis;
            var minDimension = Math.min(_this.width, _this.depth, _this.height);
            var coefficient = new BinomialCoefficient_1.default();
            _this.bezierFunctionX = new BezierFunction_1.default(pointsX, coefficient);
            _this.bezierFunctionY = new BezierFunction_1.default(pointsY, coefficient);
            _this.minRadius = minDimension / 2;
            return _this;
        }
        /**
         * Gets a point along the bezier's curve
         *
         * @this {Bezier}
         * @param  {number} time A time according to the bezier control points
         * @return {object}      An x/y pair of point values
         */
        Bezier.prototype.getPoint = function (time) {
            return {
                x: this.bezierFunctionX.getAt(time),
                y: this.bezierFunctionY.getAt(time)
            };
        };
        /**
         * Generates a 3d matrix of booleans indicating if the cell is occupied
         * @return {Boolean[][][]} A matrix of if the cell is occupied
         */
        Bezier.prototype.generate3d = function () {
            var granularity = 1;
            var out = [];
            if (this.axis == "x") {
                granularity = this.width;
            }
            else if (this.axis == "y") {
                granularity = this.depth;
            }
            else if (this.axis == "z") {
                granularity = this.height;
            }
            var samples = {};
            for (var i = 0; i < (10 * granularity); i++) {
                var time = i / (10 * granularity);
                var p = this.getPoint(time);
                var px = Math.floor(p.x * granularity);
                if (!samples.hasOwnProperty(px)) {
                    samples[px] = p.y;
                }
                else {
                    samples[px] = Math.max(p.y, samples[px]);
                }
            }
            samples[0] = this.pointsY[0];
            for (var i = 0; i < this.height; i++) {
                var radius = samples[i] * this.minRadius;
                out.push(this.generateRotation(radius));
            }
            return out;
        };
        return Bezier;
    }(BaseShape_1.default));
    exports.default = Bezier;
});
define("voxel/Shape/Cone", ["require", "exports", "voxel/Shape/BaseShape"], function (require, exports, BaseShape_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Cone = /** @class */ (function (_super) {
        __extends(Cone, _super);
        /**
         * Constructs a Cone object
         *
         * @constructor
         * @param {number} width         The width of the shape
         * @param {number} depth         The depth of the shape
         * @param {number} height         The height of the shape
         * @param {number|null} thickness The thickness of the shape, or undefined if hollow
         */
        function Cone(width, depth, height, thickness) {
            var _this = _super.call(this, width, depth, height, thickness) || this;
            var minDimension = Math.min(width, depth);
            _this.minRadius = minDimension / 2;
            return _this;
        }
        /**
         * Generates a 3d matrix of booleans indicating if the cell is occupied
         *
         * @this {Cone}
         * @return {Boolean[][][]}
         */
        Cone.prototype.generate3d = function () {
            var out = [];
            var zRadius = this.height - 0.5;
            for (var z = 0.5; z <= zRadius; z++) {
                var percent = 1 - (z / this.height);
                var circleRadius = percent * this.minRadius;
                out.push(this.generateRotation(circleRadius));
            }
            return out;
        };
        return Cone;
    }(BaseShape_2.default));
    exports.default = Cone;
});
define("voxel/Shape/Dome", ["require", "exports", "voxel/Shape/BaseShape"], function (require, exports, BaseShape_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Dome = /** @class */ (function (_super) {
        __extends(Dome, _super);
        /**
         * Constructs a Dome object
         *
         * @constructor
         * @param {number} width         The width of the shape
         * @param {number} depth         The depth of the shape
         * @param {number} height         The height of the shape
         * @param {number|null} thickness The thickness of the shape, or undefined if hollow
         */
        function Dome(width, depth, height, thickness) {
            var _this = _super.call(this, width, depth, height, thickness) || this;
            var minDimension = Math.min(_this.width, _this.depth);
            _this.minRadius = minDimension / 2;
            _this.adjustedMinRadius = (minDimension - 1) / 2;
            return _this;
        }
        /**
         * Generates a 3d matrix of booleans indicating if the cell is occupied
         *
         * @this {Dome}
         * @return {Boolean[][][]}
         */
        Dome.prototype.generate3d = function () {
            var out = [];
            var zRadius = this.height;
            var zFactor = zRadius / this.adjustedMinRadius;
            for (var z = 0.5; z < zRadius; z++) {
                var adjustedZ = Math.abs(z / zFactor);
                var circleRadius = Math.sqrt(Math.pow(this.minRadius, 2) -
                    Math.pow(Math.abs(adjustedZ), 2));
                out.push(this.generateRotation(circleRadius));
            }
            return out;
        };
        return Dome;
    }(BaseShape_3.default));
    exports.default = Dome;
});
define("voxel/Shape/Sphere", ["require", "exports", "voxel/Shape/BaseShape"], function (require, exports, BaseShape_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Sphere = /** @class */ (function (_super) {
        __extends(Sphere, _super);
        /**
         * Constructs a Sphere object
         *
         * @constructor
         * @param {number} width         The width of the shape
         * @param {number} depth         The depth of the shape
         * @param {number} height         The height of the shape
         * @param {number|null} thickness The thickness of the shape, or undefined if hollow
         */
        function Sphere(width, depth, height, thickness) {
            var _this = _super.call(this, width, depth, height, thickness) || this;
            var minDimension = Math.min(_this.width, _this.depth);
            _this.adjustedMinRadius = (minDimension - 1) / 2;
            return _this;
        }
        /**
         * Generates a 3d matrix of booleans indicating if the cell is occupied
         */
        Sphere.prototype.generate3d = function () {
            var out = [];
            var zRadius = (this.height - 1) / 2;
            var realZRadius = this.height / 2;
            var zFactor = realZRadius / this.adjustedMinRadius;
            for (var z = -zRadius; z <= zRadius; z++) {
                var adjustedZ = Math.abs(z / zFactor);
                var circleRadius = Math.sqrt(Math.pow(this.adjustedMinRadius, 2) - Math.pow(Math.abs(adjustedZ), 2));
                out.push(this.generateRotation(circleRadius));
            }
            return out;
        };
        return Sphere;
    }(BaseShape_4.default));
    exports.default = Sphere;
});
define("Voxel", ["require", "exports", "voxel/General/BezierFunction", "voxel/General/BinomialCoefficient", "voxel/Renderer/CanvasRenderer", "voxel/Renderer/ConsoleRenderer", "voxel/Renderer/SvgLayerRenderer", "voxel/Shape/BaseShape", "voxel/Shape/Bezier", "voxel/Shape/Cone", "voxel/Shape/Dome", "voxel/Shape/Sphere"], function (require, exports, BezierFunction_2, BinomialCoefficient_2, CanvasRenderer_1, ConsoleRenderer_1, SvgLayerRenderer_1, BaseShape_5, Bezier_1, Cone_1, Dome_1, Sphere_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Voxel = {
        General: {
            BezierFunction: BezierFunction_2.default,
            BinomialCoefficient: BinomialCoefficient_2.default
        },
        Renderer: {
            CanvasRenderer: CanvasRenderer_1.default,
            ConsoleRenderer: ConsoleRenderer_1.default,
            SvgLayerRenderer: SvgLayerRenderer_1.default
        },
        Shape: {
            BaseShape: BaseShape_5.default,
            Bezier: Bezier_1.default,
            Cone: Cone_1.default,
            Dome: Dome_1.default,
            Sphere: Sphere_1.default
        }
    };
    exports.default = Voxel;
});
//# sourceMappingURL=voxel.min.js.map